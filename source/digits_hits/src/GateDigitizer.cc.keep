/*----------------------
  Copyright (C): OpenGATE Collaboration

  This software is distributed under the terms
  of the GNU Lesser General  Public Licence (LGPL)
  See LICENSE.md for further details
  ----------------------*/

/*!
  \class  GateDigitizer
  GND (Gate New Digitizer) class
  2022 olga.kochebina@cea.fr

  The concept is slightly different for the old digitizer:
  Digitizer Modules (adder, readout, etc.) now are G4VDigitizerModule

*/


#include "GateDigitizer.hh"
#include "GateDigitizerMng.hh"
//#include "GateDigi.hh"
#include "GateDigitizerMessenger.hh"

#include "GateHit.hh"
#include "GateOutputMgr.hh"


#include "G4SystemOfUnits.hh"
#include "G4DigiManager.hh"


#include "GateDigitizerInitializationModule.hh"
#include "GateAdder.hh"
//#include "GateReadout.hh"

//GateDigitizer* GateDigitizer::theDigitizer=0;

//-----------------------------------------------------------------
/*GateDigitizer* GateDigitizer::GetInstance()
{
  if (!theDigitizer)
    theDigitizer = new GateDigitizer;
  return theDigitizer;
}
*/
		/*GateListManager("digitizer","digitizer module", true, true),
	  //GateClockDependent("digitizer"),
	  m_elementTypeName("digitizer module"),
	  m_systemList(0)
	  */

class GateDigitizerMng;

GateDigitizer::GateDigitizer(GateDigitizerMng* digiMng, const G4String& outputCollName)
	:GateModuleListManager(digiMng,digiMng->GetObjectName() + "/" + outputCollName,"digitizer module"),
	    //m_system( itsDigitizer->GetSystem() ),
	//    m_outputCollName("")//outputCollName),
	//    m_inputCollName("")//GateHitConvertor::GetOutputAlias())
{
	G4cout<<"GateDigitizer:: constructor"<<G4endl;
	//Initialize();
	//create a messenger for this class

	fMessenger = new GateDigitizerMessenger(this);
	//TODO : add digitizer to a digiMng
	//digiMng->AddNewSinglesDigitizer(this);//, inputCollName, outputCollName);


}


GateDigitizer::~GateDigitizer()
{
 delete fMessenger;
}


void GateDigitizer::Initialize()
{

	G4cout<<"GateDigitizer::Initialize"<<G4endl;


	GateDigitizerInitializationModule * myDM = new GateDigitizerInitializationModule( "GateDigitizerInitializationModule" );
	G4DigiManager::GetDMpointer()->AddNewModule(myDM);

	//m_collectionName="Singles";
	//G4String insertionBaseName=GatePreDigitizer::GetInstance()->GetNewInsertionBaseName();
	//moved from GateSingleDigiMaker and GatePulseProcessorChain constructors
	GateOutputMgr::GetInstance()->RegisterNewSingleDigiCollection("Singles",true);
	//m_collectionNameList.push_back("Singles");
	//m_inputCollectionNameList.push_back("Hits");
}




void GateDigitizer::RunDigitizer()
{


	G4cout<<"GateDigitizer::RunDigitizer"<<G4endl;

	/*for (G4int i=0; i<m_collectionNameList.size();i++)
		{
		G4cout<<m_collectionNameList[i]<<" from "<< m_inputCollectionNameList[i]<<G4endl;





		}
*/

	G4DigiManager *fDM = G4DigiManager::GetDMpointer();


	G4cout<<"DCtable entries " <<fDM->GetDCtable ()->entries()<<G4endl;
	fDM->List();
	//fDM->SetVerboseLevel(10);
	//G4cout<<"DCtable1 "<<fDM->GetDCtable ()->GetDCname(0)<<G4endl;
	//G4cout<<"DCtable2 "<< fDM->GetDCtable ()->GetDCname(1)<<G4endl;

	G4int DCIDinit = fDM->GetDigiCollectionID("GateDigitizerInitializationModule/Singles");
	G4int DCIDadder = fDM->GetDigiCollectionID("GateAdder/Singles");

	G4cout<<"GateDigitizerInitializationModule/Singles ID: " <<DCIDinit<<G4endl;
	G4cout<<"GateAdder/Singles ID: "<<DCIDadder<<G4endl;
	G4cout<<"GateAdder/HESingles ID: "<<fDM->GetDigiCollectionID("GateAdder/HESingles") <<G4endl;

	for (G4int i=0; i<(fDM->GetModuleCapacity());i++)
	{
		fDM->Digitize(fDM->GetDCtable()->GetDMname(i));
	}



}



//-----------------------------------------------------------------
// The next three methods were added for the multi-system approach
void GateDigitizer::AddSystem(GateVSystem* aSystem)
{
  if(!m_systemList)
    m_systemList = new GateSystemList;

  m_systemList->push_back(aSystem);

  // mhadi_Note: We have here only one pulse processor chain, this is the default chain created at the detector construction stage and
  //             which has the "Singles" outputName. So this loop here is to set a system to this chain.

  //TODO: adapt this part with coinsorter and chainName to the GND
  /* size_t i;
  for (i=0; i<GetChainNumber() ; ++i)
    {
      if(!(GetChain(i)->GetSystem()))
        GetChain(i)->SetSystem((*m_systemList)[0]);
    }

  for (i=0; i<m_coincidenceSorterList.size() ; ++i)
    {
      if(!((m_coincidenceSorterList[i])->GetSystem()))
        m_coincidenceSorterList[i]->SetSystem((*m_systemList)[0]);
    }
    */
}
//------------------------------------------------------------------------------

/* TODO
//------------------------------------------------------------------------------
GateVSystem* GateDigitizer::FindSystem(GatePulseProcessorChain* processorChain)
{
  GateVSystem* system = 0;
  if(processorChain->size() != 0)
    {
      G4String sysName = processorChain->GetProcessor(0)->GetObjectName();
      system = FindSystem(sysName);
    }
  return system;
}
//------------------------------------------------------------------------------
*/

//------------------------------------------------------------------------------
GateVSystem* GateDigitizer::FindSystem(G4String& systemName)
{
  G4int index = -1;
  for(size_t i=0; i<m_systemList->size(); i++)
    {
      if(systemName.compare(m_systemList->at(i)->GetOwnName()) == 0)
        index = i;
    }

  if(index != -1)
    return m_systemList->at(index);
  else return 0;
}
//-----------------------------------------------------------------








